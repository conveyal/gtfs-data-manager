package models;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonView;
import org.apache.commons.codec.digest.DigestUtils;
import play.Logger;
import utils.DataStore;
import utils.HashUtils;

import java.io.Serializable;
import java.util.Collection;
import java.util.Date;
import java.util.UUID;

@JsonInclude(Include.ALWAYS)
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    static private DataStore<User> userData = new DataStore<User>("users");

    public String id;
    public String username;

    @JsonView(JsonViews.DataDump.class)
    public String passwordHash;
    public String email;

    public Boolean active;
    public Boolean admin;

    // is this a user that has been autogenerated to be associated with a FeedSource?
    public boolean autogenerated;

    public Collection<ProjectPermissions> projectPermissions;

    /** A key that can be used to log in in lieu of a password */
    @JsonView(JsonViews.DataDump.class)
    public String key;

    public User(String username, String password, String email) {

        this.username = username.toLowerCase();
        this.email = email;
        this.active = true;
        this.admin = false;
        this.autogenerated = false;

        if (password == null) {
            this.passwordHash = null;
            this.generateKey();
        }
        else {
            this.key = null;
            
            if (!this.setPassword(password)) {
                this.active = false;
                this.passwordHash = null;
            }
        }
    }

    /**
     * Create an uninitialized user, used for dump/restore.
     * Should not be used under other circumstances.
     */
    public User () {
        // do nothing
    }
    
    /**
     * Set the password for this user.
     */
    public boolean setPassword (String password) {
        if (this.key != null || password == null || "".equals(password))
            return false;
        
        try {
            byte[] bytesOfMessage = password.getBytes("UTF-8");
            this.passwordHash = DigestUtils.shaHex(bytesOfMessage);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * (Re)generate the key used to log in.
     */
    private void generateKey() {
        key = UUID.randomUUID().toString();
    }

    public void save() {
        save(true);
    }

    public void save(boolean commit) {

        // assign id at save
        if(id == null || id.isEmpty()) {

            Date d = new Date();
            id = getUserId(this.username);

            Logger.info("created user u " + id);
        }

        if (commit)
            userData.save(id, this);
        else
            userData.saveWithoutCommit(id, this);

        Logger.info("saved user u " +id);
    }

    /**
     * @return true if any users exist
     */
    public static boolean usersExist () {
        return userData.size() > 0;
    }

    public void delete() {
        userData.delete(id);

        Logger.info("delete user u " +id);
    }

    public Boolean checkPassword(String password) {
        if (this.passwordHash == null || "".equals(this.passwordHash))
            return false;

        try {

            byte[] bytesOfMessage = password.getBytes("UTF-8");	

            String pHash = DigestUtils.shaHex(bytesOfMessage);

            return pHash.equals(this.passwordHash);

        }
        catch(Exception e) {

            return false;
        }
    }

    static public String getUserId(String username) {
        return HashUtils.hashString("u_" + username);
    }

    static public User getUser(String id) {

        return userData.getById(id);	
    }

    static public User getUserByUsername(String username) {

        return userData.getById(getUserId(username));	
    }

    static public Collection<User> getProjects() {

        return userData.getAll();

    }

    /**
     * This is used in Analyst Server to manage access to projects, hence the name. In data
     * manager we want to maintain as much compatibility with the analyst server user model
     * as possible, so we use the same framework. Project ID represents a Feed Source ID in this case.
     */
    public static class ProjectPermissions implements Serializable {
        public static final long serialVersionUID = 1L;

        /** The feed source ID */
        public String project_id;
        
        /** Can this user view this feed source? */
        public Boolean read;
        
        /** Can this user edit this feed source? */
        public Boolean write;
        
        /** Not used */
        public Boolean admin;

    }
    
    /**
     * Check if this user has write access to the specified project.
     */
    public boolean hasWriteAccess (String project) {
        boolean hasPermission = false;
        
        if (this.projectPermissions != null) {
            for (ProjectPermissions p : this.projectPermissions) {
                if (project.equals(p.project_id) && p.write) {
                    hasPermission = true;
                    break;                            
                }
            }
        }
        
        return hasPermission;
    }
    
    /**
     * Check if this user has read access to the specified project.
     */
    public boolean hasReadAccess (String project) {
        boolean hasPermission = false;
        
        if (this.projectPermissions != null) {
            for (ProjectPermissions p : this.projectPermissions) {
                if (project.equals(p.project_id) && p.read) {
                    hasPermission = true;
                    break;                            
                }
            }
        }
        
        return hasPermission;
    }

    /**
     * Check if:
     * a) this user can log in with a key
     * b) this key is correct for this user
     * @param key
     * @return
     */
    public boolean checkKey(String key) {
        if (this.key == null || "".equals(this.key)) {
            return false;
        }
        else {
            return this.key.equals(key);
        }
    }

    public static Collection<User> getAll() {
        return userData.getAll();
    }

    public static void commit() {
        userData.commit();
    }

}
